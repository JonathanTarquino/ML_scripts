# -*- coding: utf-8 -*-
"""feature_extract_invent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I7ApJ85qjlitSNb2aSm128iD6cb2MFH-
"""
############################  REQUIREMENTS FOR THIS CODE
# pip install pyradiomics
# pip install mahotas
# pip install pip pyfeats
# pip install medviz

#from radiomics import featureextractor
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from skimage.measure import label, regionprops, regionprops_table
import math
import glob
import skimage
from scipy.signal import convolve2d, medfilt2d, convolve
from scipy.ndimage.filters import generic_filter
from skimage.filters import sobel_h, sobel_v, sobel
from skimage.filters.rank import gradient,mean
from skimage.morphology import erosion,dilation, footprint_rectangle
from skimage.util import img_as_uint, img_as_ubyte
import cv2 as cv
import mahotas
from scipy.stats import kurtosis, skew
from scipy import ndimage as ndi
from skimage import data
from skimage.util import img_as_float
from LawsFeatures import _image_xor, lte_measures
from skimage.filters import gabor_kernel
from CollageFeatures import compute_collage2d
from HaralickFeatures import extractHaralick
from GaborFeatures import compute_gabor, gaborFilter
from Gray_and_Sobel import grayfilts2, sobelxydiag, gradfilts2


####################################################################################################################

def boundingbox2(vol, mask=[], n=[],slice_opt=None,disp_opt=None):
  min_col = 1000000
  min_row = 1000000
  max_col = 0
  max_row = 0

  # make all zero values in the original volume nonzero

  volcopy = vol

  minval = np.max(vol.ravel())/10000
  vol[vol == 0] = minval

  if len(mask)>1: #use the mask to create a bounding box:
    if np.shape(np.unique(mask))[0]>2:
      print('************ Provided mask is not binary ***************\n' )
      return []

    elif len(np.shape(mask))<3:
      print('Provided binary mask')
      label_img = label(mask)
      regions = skimage.measure.regionprops(label_img)
      for props in regions:
        minr, minc, maxr, maxc = props.bbox
        if min_col>minc:
          min_col=minc

        if min_row>minr:
          min_row=minr


        if max_col<maxc:
          max_col=maxc

        if max_row<maxr:
          max_row=maxr
      croppedV = volcopy[min_row-n:max_row+n,min_col-n:max_col+n]
      croppedM = mask[min_row-n:max_row+n,min_col-n:max_col+n]

    else:
      print('Cropping the image...')
      for sl in range(np.shape(mask)[2]):
        label_img = label(mask[:,:,sl])
        regions = skimage.measure.regionprops(label_img)
        for props in regions:
          minr, minc, maxr, maxc = props.bbox
          if min_col>minc:
            min_col=minc

          if min_row>minr:
            min_row=minr


          if max_col<maxc:
            max_col=maxc

          if max_row<maxr:
            max_row=maxr
        croppedV[:,:,sl] = volcopy[min_row-n:max_row+n,min_col-n:max_col+n]
        croppedM[:,:,sl] = mask[min_row-n:max_row+n,min_col-n:max_col+n]

  else: #use the image volume to create a bounding box:
    print('Cropping the image...')
    ### For testing puprposes
    # print(minval)
    # plt.imshow(vol>minval)
    # plt.show()
    vol_mask = vol>minval
    label_img = label(vol_mask)
    regions = skimage.measure.regionprops(label_img)
    for props in regions:
      minr, minc, maxr, maxc = props.bbox
      if min_col>minc:
        min_col=minc

      if min_row>minr:
        min_row=minr


      if max_col<maxc:
        max_col=maxc

      if max_row<maxr:
        max_row=maxr

    croppedV = volcopy[min_row-n:max_row+n,min_col-n:max_col+n]
    croppedM = mask[min_row-n:max_row+n,min_col-n:max_col+n]
  print('Cropping the image...')
  return croppedV,croppedM

###############################################################################################################

def extract2DFeatIntensities(featVol, mask, vals=1):

  # %INPUTS
  # % featVol = 3-D volume of texture features
  # % mask = 2-D annotation image
  # % vals = vector of mask values to find intensities within

  # % OUTPUT
  # % varargout = cell array(s) of intensities. Number based on length of vals
  #print('\n\tExtracting requested features\n',np.shape(featVol))
  joinFeat = []
  joinFeat = pd.DataFrame(joinFeat)

  if (not featVol.all) or (not mask.all) or (not vals):
        return []
  print('..............',featVol.shape)
  if len(np.shape(featVol)) > 2:
    print(len(np.shape(mask)))
    if len(np.shape(mask)) < 3:
      print('Generating feature vector(s) for the same mask shaped ',np.shape(joinFeat),type(joinFeat))
      for i in range(np.shape(featVol)[2]): # loop through all features
        f = featVol[:,:,i] #single feature volume
        joinFeat = pd.concat([joinFeat,pd.DataFrame(f[mask==vals].ravel())], axis=1)
    else:
      print('Generating feature vector(s) for corresponding masks shaped',np.shape(joinFeat),type(joinFeat))
      for i in range(np.shape(featVol)[2]): # loop through all features
        f = featVol[:,:,i] #single feature volume
        m = mask[:,:,i]
        joinFeat = pd.concat([joinFeat,pd.DataFrame(f[m==vals].ravel())], axis=1)


  else:
    print('Extracting single feature matrix')
    f = featVol #single feature volume
    for j in range(vals):# loop through all mask values
      joinFeat = f[mask==vals].ravel()
  #   print(f,'\n',joinFeat)
  # print(np.shape(joinFeat))
  return joinFeat

#####################################################################################################################################


########################################################################################################################################


#############################################################################################################


#################################################################################################################################

##############################################################################################

def extract2DFeatureInfo(img_org,mask_org,ws_options=[3,5,7,9,11],class_options = ['raw','gray','gradient','haralick','gabor','laws','collage'], with_stats=True):

  # im_org =        numpy array (3D or 2D), containing the original image array
  # mask_org =      numpy array (3D or 2D), containing the original mask array
  # class_options = (OPTIONAL) array of strings corresponding to desired feature classes:
  #                 DEFAULT: class_options = ['raw','gray','gradient','haralick','gabor','laws','collage'] ### still unused
  # ws_options = (  OPTIONAL) array of integers corresponding to desired window levels:
  #                 DEFAULT: ws_options = [3, 5, 7, 9, 11]
  # with_stats =    ( OPTIONAL) logic, if True it set the function to provide feature statistics togheter with the pixel wise feature information
  #                 DEFAULT: tRUE


  #Initialization
  matrixNames = []
  matrixNames = pd.DataFrame(matrixNames)
  matrixFeatures = []
  matrixFeatures = pd.DataFrame(matrixFeatures)
  statFeatures = []
  statFeatures = pd.DataFrame(statFeatures)
  statFeatureNames =[]
  statFeatures = pd.DataFrame(statFeatureNames)

  ##RECOMMENDED: CROP IMAGE AND MASK (saves time and memory)!
  [img,mask] = boundingbox2(img_org,mask_org,np.max(ws_options))

  print('Cropped Image shape:',np.shape(img))

  if len(np.shape(img)) > 2: #---------------- Checking wheter the image is a volume 3D

    if len(np.shape(mask)) < 3: #------------- Checking if there is a mask for each slice of the volume

      for i in range(np.shape(img)[2]): #----- loop through all slices of the volumen

        ## ..............2D Feature Intensity Extraction
        print('Extracting Features for provide image slices and a single mask')

        #------------- Raw intensity features ----------------
        feat_vect = extract2DFeatIntensities(img[:,:,i], mask)


        #--------------Gray Level Statistics----------------%
        print('\nExtracting Gray Level Statistics:\n')
        grayFeats = []
        grayFeats = pd.DataFrame(grayFeats)
        for ws in ws_options:
          print('\t Using a window size of ',ws,'\n')
          gf = grayfilts2(img[:,:,i],ws)
          # print('Gray result:',np.shape(gf))
          gf = grayfilts2(img[:,:,i],ws)
          # print('Gray result:',np.shape(gf))
          feat_vect = extract2DFeatIntensities(gf, mask)
          # print('Feature vector shape:',np.shape(feat_vect))

    else: # -------------- If there is not a mask for each slice in the voluem

      ##2D Feature Intensity Extraction
      print('\t Extracting intensity Features for provide single image slice:\n')

      #------------- Raw intensity features ----------------
      print('Raw intensities')
      feat_vect = extract2DFeatIntensities(img, mask)
      print('Raw intensity Feature vector shape:..............\n',np.shape(feat_vect))
      print(feat_vect)

      if with_stats == True:
        statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.mean(),feat_vect.std(),skew(feat_vect),kurtosis(feat_vect)])],axis = 1)
        statistics = ['Mean_of_','std_of_','skew_of_','kurtosis_of_']



      matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis = 0)
      matrixNames = pd.concat([pd.DataFrame(['Raw intensity']),matrixNames])
      # statFeatureNames = pd.concat([pd.DataFrame(statFeatureNames),pd.DataFrame(['Mean Raw','std Raw','skew Raw','Kurtosis Raw'])])
      print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(statFeatures),matrixNames)


      #--------------Gray Level Statistics----------------%
      print('\n \t Extracting Gray Level Statistics:\n')


      for ws in ws_options:

        print('\n \t Using a window size of ',ws,'\n')
        gf = grayfilts2(img,ws)
        feat_names = ['Mean Image_','Median Image_','std Image_','Windowed range image_']
        feat_vect = extract2DFeatIntensities(gf, mask)
        print('Gray level Feature vector statistics:...............\n',np.shape(feat_vect))
        f_names = [x+'_w'+str(ws) for x in feat_names]
        matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
        matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)


        if with_stats == True:
          for f_idx in range(feat_vect.shape[1]):
            statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                                feat_vect.iloc[:,f_idx].std(),
                                                                skew(feat_vect.iloc[:,f_idx]),
                                                                kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)

        print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(matrixNames),np.shape(statFeatures))
        print(matrixNames,'\n',statFeatureNames)

        # ------------------ Haralick features ------------------------------
        print('\nExtracting Haralick-based (GLCM) features:\n')
        haralick_labels = ["Haralick Angular Second Moment",
                    "Haralick Contrast",
                    "Haralick Correlation",
                    "Haralick Sum of Squares: Variance",
                    "Haralick Inverse Difference Moment",
                    "Haralick Sum Average",
                    "Haralick Sum Variance",
                    "Haralick Sum Entropy",
                    "Haralick Entropy",
                    "Haralick Difference Variance",
                    "Haralick Difference Entropy",
                    "Haralick Information Measure of Correlation 1",
                    "Haralick Information Measure of Correlation 2"]
        HaralickFeat = extractHaralick(img,ws)
        feat_vect = extract2DFeatIntensities(HaralickFeat, mask)
        #print('Haralick feature vector statistics:.................\n',np.shape(feat_vect))
        f_names = [x+'_w'+str(ws) for x in haralick_labels]
        matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
        matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)
        if with_stats == True:
          for f_idx in range(feat_vect.shape[1]):
            statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                                feat_vect.iloc[:,f_idx].std(),
                                                                skew(feat_vect.iloc[:,f_idx]),
                                                                kurtosis(feat_vect.iloc[:,f_idx])])])

        print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(statFeatures),'\n',matrixNames)



        #---------------- Laws--------------------------------------
        print('\nExtracting Laws features:\n')
        Laws_out = lte_measures(img_org, mask=None,l=ws)
        print('+++++++++++++++++++++++++++++++++++++++++++Laws out \n',np.shape(Laws_out[0]))
        feat_vect = extract2DFeatIntensities(Laws_out[0], mask_org[1:-1,1:-1])
        f_names = Laws_out[1]
        matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
        matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)

        if with_stats == True:
          for f_idx in range(feat_vect.shape[1]):
            statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                                feat_vect.iloc[:,f_idx].std(),
                                                                skew(feat_vect.iloc[:,f_idx]),
                                                                kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
        print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures), statFeatures.shape, '\n',matrixNames)


        # ---------------- Collage ------------------------------------------
        print('\nExtracting Collage features:\n')
        # due to limitation in the minumum patch size of collage pack use "img_org" instead of the cropped version "img"
        mask_complete = np.ones(np.shape(img_org)) # a fake mask is used to evaluate the whole image
        coll = compute_collage2d(img_org,mask_complete, haralick_windows=ws)
        feat_vect = extract2DFeatIntensities(coll[1], mask_org)
        print(coll[2])
        f_names = [x+'_w'+str(ws) for x in coll[2]]
        matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
        matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)

        if with_stats == True:
          for f_idx in range(feat_vect.shape[1]):
            statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                                feat_vect.iloc[:,f_idx].std(),
                                                                skew(feat_vect.iloc[:,f_idx]),
                                                                kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
        print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),'\n',matrixFeatures,'\n',statFeatures.shape,matrixNames)


        #------------- Gradient ------------------------------
        print('\nExtracting Gradient features:\n')
        feat_names = ['Gradient sobelx','Gradient sobely','Gradient sobelxy','Gradient sobelyx','Gradient x','Gradient y','Gradient magnitude','Gradient dx','Gradient dy','Gradient diagonal']
        gradOut = gradfilts2(img)
        # print('Grad results:\n',gradOut)
        f_names = [x+'_w'+str(ws) for x in feat_names]
        feat_vect = extract2DFeatIntensities(gradOut, mask)
        # print('Gray level statistics:\n',np.shape(feat_vect),feat_vect[0:100])
        matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
        matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)

        if with_stats == True:
          for f_idx in range(feat_vect.shape[1]):
            statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                                feat_vect.iloc[:,f_idx].std(),
                                                                skew(feat_vect.iloc[:,f_idx]),
                                                                kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
        print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures), np.shape(statFeatures),matrixNames)



      #---------------- Gabor -------------------------------------------
      print('\n Extracting Gabor features')
      gabor_matrix = gaborFilter(img)
      feat_vect = extract2DFeatIntensities(gabor_matrix[0], mask)
      matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
      matrixNames = pd.concat([pd.DataFrame(gabor_matrix[1]),matrixNames],axis = 0)

      if with_stats == True:
        for f_idx in range(feat_vect.shape[1]):
          statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                                feat_vect.iloc[:,f_idx].std(),
                                                                skew(feat_vect.iloc[:,f_idx]),
                                                                kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
      print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(statFeatures),matrixNames)

      print(np.shape(matrixNames))
      print(matrixNames)

      for name in range(len(matrixNames.iloc[:,0])):
        print('--------->',matrixNames.iloc[name,0],[r+matrixNames.iloc[name,0] for r in statistics])
        statFeatureNames = pd.concat([pd.DataFrame([r+matrixNames.iloc[name,0] for r in statistics]),pd.DataFrame(statFeatureNames)])

  else:

    ##  --------------------------------------------------   2D Feature Intensity Extraction

    print('\t Extracting intensity Features for provide single image slice:\n')

    #------------- Raw intensity features ----------------
    print('Raw intensities')
    feat_vect = extract2DFeatIntensities(img, mask)
    print('Raw intensity Feature vector shape:..............\n',np.shape(feat_vect))
    print(feat_vect)

    if with_stats == True:
      statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.mean(),feat_vect.std(),skew(feat_vect),kurtosis(feat_vect)])],axis = 1)
      statistics = ['Mean_of_','std_of_','skew_of_','kurtosis_of_']



    matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis = 0)
    matrixNames = pd.concat([pd.DataFrame(['Raw intensity']),matrixNames])
    # statFeatureNames = pd.concat([pd.DataFrame(statFeatureNames),pd.DataFrame(['Mean Raw','std Raw','skew Raw','Kurtosis Raw'])])
    print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(statFeatures),matrixNames)


    #--------------Gray Level Statistics----------------%
    print('\n \t Extracting Gray Level Statistics:\n')


    for ws in ws_options:

      print('\n \t Using a window size of ',ws,'\n')
      gf = grayfilts2(img,ws)
      feat_names = ['Mean Image_','Median Image_','std Image_','Windowed range image_']
      feat_vect = extract2DFeatIntensities(gf, mask)
      print('Gray level Feature vector statistics:...............\n',np.shape(feat_vect))
      f_names = [x+'_w'+str(ws) for x in feat_names]
      matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
      matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)


      if with_stats == True:
        for f_idx in range(feat_vect.shape[1]):
          statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                               feat_vect.iloc[:,f_idx].std(),
                                                               skew(feat_vect.iloc[:,f_idx]),
                                                               kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)

      print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(matrixNames),np.shape(statFeatures))
      print(matrixNames,'\n',statFeatureNames)

      # ------------------ Haralick features ------------------------------
      print('\nExtracting Haralick-based (GLCM) features:\n')
      haralick_labels = ["Haralick Angular Second Moment",
                   "Haralick Contrast",
                   "Haralick Correlation",
                   "Haralick Sum of Squares: Variance",
                   "Haralick Inverse Difference Moment",
                   "Haralick Sum Average",
                   "Haralick Sum Variance",
                   "Haralick Sum Entropy",
                   "Haralick Entropy",
                   "Haralick Difference Variance",
                   "Haralick Difference Entropy",
                   "Haralick Information Measure of Correlation 1",
                   "Haralick Information Measure of Correlation 2"]
      HaralickFeat = extractHaralick(img,ws)
      feat_vect = extract2DFeatIntensities(HaralickFeat, mask)
      #print('Haralick feature vector statistics:.................\n',np.shape(feat_vect))
      f_names = [x+'_w'+str(ws) for x in haralick_labels]
      matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
      matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)
      if with_stats == True:
        for f_idx in range(feat_vect.shape[1]):
          statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                               feat_vect.iloc[:,f_idx].std(),
                                                               skew(feat_vect.iloc[:,f_idx]),
                                                               kurtosis(feat_vect.iloc[:,f_idx])])])

      print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(statFeatures),'\n',matrixNames)



      #---------------- Laws--------------------------------------
      print('\nExtracting Laws features:\n')
      print(mask_org.shape)
      Laws_out = lte_measures(img_org, mask=None,l=ws)
      print('+++++++++++++++++++++++++++++++++++++++++++Laws out \n',np.shape(Laws_out[0]))
      feat_vect = extract2DFeatIntensities(Laws_out[0], mask_org) #[1:-1,1:-1])
      f_names = Laws_out[1]
      matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
      matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)

      if with_stats == True:
        for f_idx in range(feat_vect.shape[1]):
          statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                               feat_vect.iloc[:,f_idx].std(),
                                                               skew(feat_vect.iloc[:,f_idx]),
                                                               kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
      print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures), statFeatures.shape, '\n',matrixNames)


      # ---------------- Collage ------------------------------------------
      print('\nExtracting Collage features:\n')
      # due to limitation in the minumum patch size of collage pack use "img_org" instead of the cropped version "img"
      mask_complete = np.ones(np.shape(img_org)) # a fake mask is used to evaluate the whole image
      coll = compute_collage2d(img_org,mask_complete, haralick_windows=ws)
      feat_vect = extract2DFeatIntensities(coll[1], mask_org)
      print(coll[2])
      f_names = [x+'_w'+str(ws) for x in coll[2]]
      matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
      matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)

      if with_stats == True:
        for f_idx in range(feat_vect.shape[1]):
          statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                               feat_vect.iloc[:,f_idx].std(),
                                                               skew(feat_vect.iloc[:,f_idx]),
                                                               kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
      print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),'\n',matrixFeatures,'\n',statFeatures.shape,matrixNames)


      #------------- Gradient ------------------------------
      print('\nExtracting Gradient features:\n')
      feat_names = ['Gradient sobelx','Gradient sobely','Gradient sobelxy','Gradient sobelyx','Gradient x','Gradient y','Gradient magnitude','Gradient dx','Gradient dy','Gradient diagonal']
      gradOut = gradfilts2(img)
      # print('Grad results:\n',gradOut)
      f_names = [x+'_w'+str(ws) for x in feat_names]
      feat_vect = extract2DFeatIntensities(gradOut, mask)
      # print('Gray level statistics:\n',np.shape(feat_vect),feat_vect[0:100])
      matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
      matrixNames = pd.concat([pd.DataFrame(f_names),matrixNames],axis = 0)

      if with_stats == True:
        for f_idx in range(feat_vect.shape[1]):
          statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                               feat_vect.iloc[:,f_idx].std(),
                                                               skew(feat_vect.iloc[:,f_idx]),
                                                               kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
      print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures), np.shape(statFeatures),matrixNames)



    #---------------- Gabor -------------------------------------------
    print('\n Extracting Gabor features')
    gabor_matrix = gaborFilter(img)
    feat_vect = extract2DFeatIntensities(gabor_matrix[0], mask)
    matrixFeatures = pd.concat([pd.DataFrame(feat_vect),matrixFeatures], axis=1)
    matrixNames = pd.concat([pd.DataFrame(gabor_matrix[1]),matrixNames],axis = 0)

    if with_stats == True:
      for f_idx in range(feat_vect.shape[1]):
        statFeatures = pd.concat([statFeatures,pd.DataFrame([feat_vect.iloc[:,f_idx].mean(),
                                                              feat_vect.iloc[:,f_idx].std(),
                                                              skew(feat_vect.iloc[:,f_idx]),
                                                              kurtosis(feat_vect.iloc[:,f_idx])])], axis = 0)
    print('xxxxxxxxxxxxxxxx',np.shape(matrixFeatures),np.shape(statFeatures),matrixNames)

    # print(np.shape(matrixNames))
    print(matrixNames)

    for name in range(len(matrixNames.iloc[:,0])):
      # print('--------->',matrixNames.iloc[name,0],[r+matrixNames.iloc[name,0] for r in statistics])
      statFeatureNames = pd.concat([pd.DataFrame([r+matrixNames.iloc[name,0] for r in statistics]),pd.DataFrame(statFeatureNames)])

    return (matrixNames,matrixFeatures,statFeatures,statFeatureNames)
